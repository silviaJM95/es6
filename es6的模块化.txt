模块化：使用import和export进行导入和导出

export命令可以出现在模块文件的任何位置，但是不允许出现在跨级作用域内
let c = 1;
funciton (name) {
 export c;//syntaxError
}

export 输出值是动态绑定的

import可以使模块整体加载：import * as v from './demo'

*表示整体加载，as后是别名

export default命令

使用babelJS / Traceur把ES6转换为兼容ES5版本的js代码

ES6 的模块化的基本规则或特点：
每一个模块只加载一次，每一个JS只执行一次，如果下一次再去加载同目录下的文件，直接从内存中读取，一个模块就是一个单例，或者说是一个对象

每一个模块内声明的变量都是局部变量，不会污染全局作用域

模块内的变量或者函数可以通过export导出

一个模块可以导入别的模块

每一个导入的js模块都是活的，每一次访问该模块的变量或者函数都是最新的

从fs模块中加载三个方法：
import { stat, exists, readFile } from 'fs' 称为编译时加载或者静态加载

ES6模块自动采用严格模式
严格模式主要有以下限制：
1、变量必须声明后使用
2、函数的参数不能有同名属性，否则报错
3、不能使用with语句
4、不能对只读属性赋值，否则报错
5、不能使用前缀为0表示八进制数，否则报错
6、不能删除不可删除的属性，否则报错
7、不能删除变量delete prop，会报错，只能删除属性delete global[prop]
8、eval不会在它的外层作用域引入变量
9、eval和arguments不能被重新赋值
10、arguments不会自动反映函数参数的变化
11、不能使用arguments.callee / arguments.caller
12、禁止this指向全局对象
尤其注意this的限制。
ES6模块中，顶层的this指向undefined，不应该在顶层的代码中使用this

export命令 ―― 用于规定模块的对外接口
inport命令 ―― 用于输入其他模块提供的功能

import 是静态执行，所以不能使用表达式和变量

模块的整体加载 ―― 使用*指定一个对象，所有输出值都加载在这个对象上面

export defalut 为模块指定默认输出，只能使用一次

import()函数使用场景
1、按需加载
2、条件加载 ―― 可以放在if代码块中，根据不同的情况，加载不同的模块
3、动态的模块路径 ―― 允许模块路径动态生成

模块的循环加载：
循环加载指的是：a脚本的执行依赖b脚本，而b脚本的执行又依赖a脚本
"循环加载"表示存在强耦合，可能导致递归加载，应该避免出现

两种处理方式： CommonJS / ES6
CommonJS模块的加载原理：
CommonJS的一个模块，就是一个脚本文件，require命令第一次加载该脚本，就会执行整个脚本，然后在内存中生成一个对象

CommonJS模块的循环加载：
CommonJS模块的重要特性是加载时执行，即脚本代码在require的时候，就会全部执行

CommonJS的做法是，一旦出现某个模块被“循环加载”，就只输出已经执行的部分，还未执行的部分不会输出

ES6的模块循环加载：
遇到加载命令import时，不会去执行模块，而是只生成一个引用，等到真正需要用的时候，再到模块里面去取值

因此，ES6模块是动态引用，不存在缓存值的问题，而模块里面的变量，绑定在其所在的模块

说一下AMD和CMD
对于依赖的模块，AMD是提前执行，CMD是延迟执行
AMD推荐依赖前置，CMD推荐依赖就近



